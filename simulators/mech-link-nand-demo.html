<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Spring-Hinge NAND Simulator</title>
    <style>
      body {
        background-color: #f0f0f0;
        padding: 30px;
      }
      .content {
        max-width: 1200px;
        margin: auto;
      }
      .inputs {
        display: flex;
        flex-direction: column;
        margin-bottom: 20px;
      }
      .inputs button {
        width: 60px;
      }
      .btn-group {
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 10px;
      }
      .btn-group label {
        font-weight: bold;
        min-width: 3em;
      }
      .btn-group .true-button:hover {
        border: 2px solid green;
      }
      .btn-group .false-button:hover {
        border: 2px solid red;
      }
      .btn-group .reset-button:hover {
        border: 2px solid grey;
      }
      .btn-controls {
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 10px;
      }
      .green {
        background-color: green;
        border-radius: 3px;
        padding-left: 6px;
        padding-right: 6px;
        color: white;
      }
      .red {
        background-color: red;
        border-radius: 3px;
        padding-left: 6px;
        padding-right: 6px;
        color: white;
      }
      .grey {
        background-color: grey;
        border-radius: 3px;
        padding-left: 6px;
        padding-right: 6px;
        color: white;
      }
      .black {
        background-color: black;
        border-radius: 3px;
        padding-left: 6px;
        padding-right: 6px;
        color: red;
      }
      .result {
        display: flex;
        flex-direction: row;
      }
      .result label {
        font-weight: bold;
        width: 3.5em;
        text-align: center;
        margin-right: 1em;
        padding-left: 6px;
        padding-right: 6px;
      }
      .result .explainer {
        font-weight: bold;
        min-width: 6.5em;
      }
      canvas {
        background: #f0f0f0;
        display: block;
        border: 2px dashed grey;
        border-radius: 15px;
      }
    </style>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div class="content">
      <div class="infobox">
        <h1
          style="
            position: sticky;
            top: 0;
            background-color: #f0f0f0;
            z-index: 10;
            border-bottom: 1.5px solid grey;
            padding-bottom: 5px;
          "
        >
          Mechanical NAND Gate Simulation Using Only Links and Rotary Joints
        </h1>
        <h2>
          Based on work from
          <a
            href="https://doi.org/10.48550/arXiv.1801.03534"
            style="font-style: italic"
          >
            Mechanical Computing Systems Using Only Links and Rotary Joints
          </a>
        </h2>
        <h2>Original authors:</h2>
        <ol>
          <li><h3>Ralph C. Merkle</h3></li>
          <li><h3>Robert A. Freitas Jr.</h3></li>
          <li><h3>Tad Hogg</h3></li>
          <li><h3>Thomas E. Moore</h3></li>
          <li><h3>Matthew S. Moses</h3></li>
          <li><h3>James Ryley</h3></li>
        </ol>

        <h2>Code monkeys:</h2>
        <ul>
          <li>
            <h4>
              Chief Technology Wizard: Tennyson Bardwell -
              <a href="mailto:tennysontaylorbardwell@gmail.com"
                >tennysontaylorbardwell@gmail.com</a
              >
            </h4>
          </li>
          <li>
            <h4>
              Senior HTML Engineer: Haochen Xu -
              <a href="mailto:hcxu@utexas.edu">hcxu@utexas.edu</a>
            </h4>
          </li>
        </ul>
      </div>

      <canvas id="simulator" width="1200" height="600"></canvas>

      <div
        style="
          display: flex;
          flex-direction: row;
          justify-content: space-evenly;
        "
      >
        <div
          class="inputs"
          style="display: flex; flex-direction: column; gap: 15px; width: 330px"
        >
          <h2 style="margin-bottom: 0px">Input Controls</h2>
          <div class="btn-group">
            <label>Clock</label>
            <div class="btn-controls" id="clock-control">
              <button
                class="true-button"
                id="clock-button-true"
                onclick="c.set(1)"
              >
                tick
              </button>
              <button
                class="false-button"
                id="clock-button-false"
                onclick="c.set(0)"
              >
                tock
              </button>
            </div>
          </div>
          <div class="btn-group">
            <label>A</label>
            <div class="btn-controls" id="input-a">
              <button
                class="true-button"
                id="A-button-true"
                onclick="a.set(true); calculateExpectedOutput(a, b);"
              >
                TRUE
              </button>
              <button
                class="false-button"
                id="A-button-false"
                onclick="a.set(false); calculateExpectedOutput(a, b);"
              >
                FALSE
              </button>
              <button
                class="reset-button"
                id="A-button-reset"
                onclick="a.set(null); calculateExpectedOutput(a, b);"
              >
                Reset
              </button>
            </div>
          </div>
          <div class="btn-group">
            <label>B</label>
            <div class="btn-controls" id="input-b">
              <button
                class="true-button"
                id="B-button-true"
                onclick="b.set(true); calculateExpectedOutput(a, b);"
              >
                TRUE
              </button>
              <button
                class="false-button"
                id="B-button-false"
                onclick="b.set(false); calculateExpectedOutput(a, b);"
              >
                FALSE
              </button>
              <button
                class="reset-button"
                id="B-button-reset"
                onclick="b.set(null); calculateExpectedOutput(a, b);"
              >
                Reset
              </button>
            </div>
          </div>
        </div>

        <div
          class="outputs"
          style="display: flex; flex-direction: column; gap: 15px"
        >
          <h2 style="margin-bottom: 0px">Outputs</h2>
          <div class="result">
            <div class="explainer">Equation:</div>
            <label id="i0-result">null</label>
            <label>NAND</label>
            <label id="i1-result">null</label>
          </div>
          <div class="result">
            <div class="explainer">Expected:</div>
            <label id="expected-result"></label>
          </div>
          <div class="result">
            <div class="explainer">Simulated:</div>
            <label id="simulated-result"></label>
          </div>
        </div>
      </div>
    </div>
    <script>
      // Global parameters
      const dt = 0.016,
        gravity = 0.0,
        scale = 15;

      // Particle: simple point mass (no rotation)
      class Particle {
        constructor(x, y, fixed = false, color = "#000") {
          this.x = x;
          this.y = y;
          this.vx = 0;
          this.vy = 0;
          this.fixed = fixed;
          this.color = color;
          this.target_x = null;
          this.target_y = null;
          this.target_speed = null;
        }
        applyForce(fx, fy) {
          if (!this.fixed) {
            this.vx += fx * dt;
            this.vy += fy * dt;
          }
        }
        update() {
          if (!this.fixed) {
            this.vx *= 0.99;
            this.vy *= 0.99;
            this.x += this.vx * dt;
            this.y += this.vy * dt;
          } else if (this.target_x !== null) {
            let dx = this.target_x - this.x;
            let dy = this.target_y - this.y;
            let diff = Math.sqrt(dx * dx + dy + dy);
            if (diff < this.target_speed) {
              this.x = this.target_x;
              this.target_x = null;
              this.y = this.target_y;
              this.target_y = null;
            } else {
              this.x += (this.target_speed * dx) / diff;
              this.y += (this.target_speed * dy) / diff;
            }
          }
        }
        draw(ctx) {
          ctx.beginPath();
          ctx.arc(this.x * scale, this.y * scale, 6, 0, 2 * Math.PI);
          ctx.fillStyle = this.color;
          ctx.fill();
        }
        applyForceAtPoint(x, y, fx, fy) {
          this.applyForce(fx, fy);
        }
      }

      // Ridged: rigid body defined by local points & segments; local coords remain unchanged.
      // Each local point is augmented with com_x_offset and com_y_offset computed from the weighted COM.
      class Ridged {
        constructor(localPoints, segments, options = {}) {
          // Copy points without shifting them.
          this.localPoints = localPoints.map((p) => ({ x: p.x, y: p.y }));
          this.segments = segments;
          this.color = options.color || "#088";
          this.lineWidth = options.lineWidth || 2;
          // Compute weighted COM (using segment lengths)
          let total = 0,
            wx = 0,
            wy = 0;
          for (let seg of segments) {
            let p1 = this.localPoints[seg[0]],
              p2 = this.localPoints[seg[1]];
            let len = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            total += len;
            wx += ((p1.x + p2.x) / 2) * len;
            wy += ((p1.y + p2.y) / 2) * len;
          }
          let comX = wx / total,
            comY = wy / total;
          for (let p of this.localPoints) {
            p.com_x_offset = p.x - comX;
            p.com_y_offset = p.y - comY;
          }
          this.mass = options.mass || total;
          // Compute moment of inertia (approximation)
          let I = 0;
          for (let seg of segments) {
            let p1 = this.localPoints[seg[0]],
              p2 = this.localPoints[seg[1]];
            let len = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            let m_seg = this.mass * (len / total);
            let midx = (p1.com_x_offset + p2.com_x_offset) / 2;
            let midy = (p1.com_y_offset + p2.com_y_offset) / 2;
            I += (m_seg * len * len) / 12 + m_seg * (midx * midx + midy * midy);
          }
          this.fixY = options.fixY || false;
          this.fixAngle = options.fixAngle || false;
          this.inertia = options.inertia || I;
          this.posX = options.posX || 0;
          this.posY = options.posY || 0;
          this.angle = options.angle || 0;
          this.vx = options.vx || 0;
          this.vy = options.vy || 0;
          this.angularVelocity = options.angularVelocity || 0;
          this.fx = 0;
          this.fy = 0;
          this.torque = 0;
        }
        applyForceAtPoint(x, y, fx, fy) {
          this.fx += fx;
          this.fy += fy;
          let rx = x - this.posX,
            ry = y - this.posY;
          this.torque += rx * fy - ry * fx;
        }
        update() {
          this.fy += gravity * this.mass;
          let ax = this.fx / this.mass,
            ay = this.fy / this.mass;
          this.vx += ax * dt;
          this.vy += ay * dt;
          if (this.fixY) {
            this.vy = 0;
            // console.log(this.posY);
          }
          this.posX += this.vx * dt;
          this.posY += this.vy * dt;
          let angularAcc = this.torque / this.inertia;
          this.angularVelocity += angularAcc * dt;
          if (this.fixAngle) {
            angularVelocity = 0;
          }
          this.angle += this.angularVelocity * dt;
          if (isNaN(this.angle)) {
            debugger;
          }
          this.vx *= 0.99;
          this.vy *= 0.99;
          this.angularVelocity *= 0.99;
          this.fx = 0;
          this.fy = 0;
          this.torque = 0;
        }
        getWorldPoints() {
          let pts = [];
          let cos = Math.cos(this.angle),
            sin = Math.sin(this.angle);
          for (let p of this.localPoints) {
            pts.push({
              x: this.posX + p.x * cos - p.y * sin,
              y: this.posY + p.x * sin + p.y * cos,
            });
          }
          return pts;
        }
        draw(ctx) {
          let pts = this.getWorldPoints();
          ctx.strokeStyle = this.color;
          ctx.lineWidth = this.lineWidth;
          for (let seg of this.segments) {
            let p1 = pts[seg[0]],
              p2 = pts[seg[1]];
            ctx.beginPath();
            ctx.moveTo(p1.x * scale, p1.y * scale);
            ctx.lineTo(p2.x * scale, p2.y * scale);
            ctx.stroke();
          }
        }
        // For selection, return nearest world point.
        getNearestPoint(mx, my) {
          let pts = this.getWorldPoints(),
            best = null,
            minD = Infinity;
          for (let p of pts) {
            let d = Math.hypot(p.x - mx, p.y - my);
            if (d < minD) {
              minD = d;
              best = p;
            }
          }
          return { point: best, distance: minD };
        }
      }

      // Hinge: attached to an object's local offset; can apply angular resistance.
      class Hinge {
        constructor(obj, offset, options = {}) {
          this.obj = obj;
          this.offset = offset; // local {x, y}
          this.hingeStiffness = options.hingeStiffness || 0;
          this.hingeDamping = options.hingeDamping || 0;
          this.constrainRotation = options.constrainRotation || false;
          this.desiredRelAngle = 0;
        }
        // Set desired relative angle based on spring's global direction.
        setDesired(springDir) {
          let offsetAngle = Math.atan2(this.offset.y, this.offset.x);
          let objAngle = this.obj.angle !== undefined ? this.obj.angle : 0;
          let hingeGlobal = objAngle + offsetAngle;
          this.desiredRelAngle = springDir - hingeGlobal;
        }
        update(springDir) {
          if (!this.constrainRotation) return;
          let offsetAngle = Math.atan2(this.offset.y, this.offset.x);
          let objAngle = this.obj.angle !== undefined ? this.obj.angle : 0;
          let hingeGlobal = objAngle + offsetAngle;
          let error = hingeGlobal + this.desiredRelAngle - springDir;
          error = ((error + Math.PI) % (2 * Math.PI)) - Math.PI;
          let torque =
            -this.hingeStiffness * error -
            this.hingeDamping * (this.obj.angularVelocity || 0);
          if (this.obj.torque !== undefined) this.obj.torque += torque;
        }
      }

      // Spring: unified spring connecting two objects (Particle or Ridged) at given local offsets.
      // Creates hinges at endpoints to provide angular resistance/dampening.
      class Spring {
        constructor(
          objA,
          objB,
          offsetA,
          offsetB,
          naturalLength,
          stiffness,
          damping,
          options = {}
        ) {
          this.objA = objA;
          this.objB = objB;
          this.offsetA = offsetA;
          this.offsetB = offsetB;
          this.naturalLength = naturalLength;
          this.stiffness = stiffness;
          this.damping = damping;
          this.color = options.color || "#333";
          this.exp = options.exp || 1;
          this.hingeA = new Hinge(this.objA, this.offsetA, {
            hingeStiffness: options.hingeStiffness || 0,
            hingeDamping: options.hingeDamping || 0,
            constrainRotation: options.constrainRotation || false,
          });
          this.hingeB = new Hinge(this.objB, this.offsetB, {
            hingeStiffness: options.hingeStiffness || 0,
            hingeDamping: options.hingeDamping || 0,
            constrainRotation: options.constrainRotation || false,
          });
          let A = this.getWorldPoint(this.objA, this.offsetA);
          let B = this.getWorldPoint(this.objB, this.offsetB);
          let initialDir = Math.atan2(B.y - A.y, B.x - A.x);
          this.hingeA.setDesired(initialDir);
          this.hingeB.setDesired(initialDir);
        }
        getWorldPoint(obj, offset) {
          if (obj instanceof Ridged) {
            let cos = Math.cos(obj.angle),
              sin = Math.sin(obj.angle);
            return {
              x: obj.posX + offset.x * cos - offset.y * sin,
              y: obj.posY + offset.x * sin + offset.y * cos,
            };
          } else {
            // Particle
            return { x: obj.x, y: obj.y };
          }
        }
        update() {
          let A = this.getWorldPoint(this.objA, this.offsetA);
          let B = this.getWorldPoint(this.objB, this.offsetB);
          let dx = B.x - A.x,
            dy = B.y - A.y,
            dist = Math.hypot(dx, dy);
          if (dist === 0) return;
          let diff = dist - this.naturalLength;
          let nx = dx / dist,
            ny = dy / dist;
          let vAx = this.objA.vx || 0,
            vAy = this.objA.vy || 0;
          let vBx = this.objB.vx || 0,
            vBy = this.objB.vy || 0;
          let relVel = (vBx - vAx) * nx + (vBy - vAy) * ny;
          let forceMag =
            this.stiffness * Math.pow(diff, this.exp) + this.damping * relVel;
          let fx = forceMag * nx,
            fy = forceMag * ny;
          if (this.objA.applyForceAtPoint) {
            this.objA.applyForceAtPoint(A.x, A.y, fx, fy);
          } else {
            this.objA.applyForce(fx, fy);
          }
          if (this.objB.applyForceAtPoint) {
            this.objB.applyForceAtPoint(B.x, B.y, -fx, -fy);
          } else {
            this.objB.applyForce(-fx, -fy);
          }
          let springDir = Math.atan2(dy, dx);
          this.hingeA.update(springDir);
          this.hingeB.update(springDir);
        }
        draw(ctx) {
          let A = this.getWorldPoint(this.objA, this.offsetA);
          let B = this.getWorldPoint(this.objB, this.offsetB);
          ctx.beginPath();
          ctx.moveTo(A.x * scale, A.y * scale);
          ctx.lineTo(B.x * scale, B.y * scale);
          ctx.strokeStyle = this.color;
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }

      // --- Simulation Setup ---
      const canvas = document.getElementById("simulator"),
        ctx = canvas.getContext("2d");

      // Arrays to hold objects
      let particles = [],
        ridgedObjects = [],
        springs = [],
        listeners = [];

      function demo() {
        // Create a two-segment rod using particles connected by a Spring.
        let fixedP = new Particle(2, 1, true, "#f00");
        let midP = new Particle(3, 1, false, "#000");
        let freeP = new Particle(4, 1, false, "#000");
        particles.push(fixedP, midP, freeP);
        springs.push(
          new Spring(fixedP, midP, { x: 0, y: 0 }, { x: 0, y: 0 }, 1, 500, 50, {
            color: "#555",
            hingeStiffness: 50,
            hingeDamping: 5,
            constrainRotation: true,
          })
        );
        springs.push(
          new Spring(midP, freeP, { x: 0, y: 0 }, { x: 0, y: 0 }, 1, 500, 50, {
            color: "#555",
            hingeStiffness: 50,
            hingeDamping: 5,
            constrainRotation: true,
          })
        );

        // Create a ridged rectangle.
        let rectLocal = [
          { x: -0.5, y: -0.2 },
          { x: 0.5, y: -0.2 },
          { x: 0.5, y: 0.2 },
          { x: -0.5, y: 0.2 },
        ];
        let rectSegs = [
          [0, 1],
          [1, 2],
          [2, 3],
          [3, 0],
        ];
        let rectangle = new Ridged(rectLocal, rectSegs, {
          posX: 3,
          posY: 3,
          angle: 0,
          color: "#0a0",
        });
        ridgedObjects.push(rectangle);

        // Connect the rectangle to the free end of the rod using a Spring.
        // For rectangle, attach at local point (0, -0.2); for freeP, use (0,0).
        springs.push(
          new Spring(
            freeP,
            rectangle,
            { x: 0, y: 0 },
            { x: 0, y: -0.2 },
            0.1,
            300,
            30,
            {
              color: "#a0a",
              hingeStiffness: 100,
              hingeDamping: 10,
              constrainRotation: true,
            }
          )
        );
      }

      class Frame {
        constructor(angle, x, y) {
          this.angle = angle;
          this.x = x;
          this.y = y;
        }

        toWorld(x, y) {
          const sin = Math.sin(this.angle);
          const cos = Math.cos(this.angle);
          return {
            x: this.x + x * cos - y * sin,
            y: this.y + y * cos + x * sin,
          };
        }
      }

      class DataLink {
        constructor(x, y, angle = 0, width = 1, hight = 1) {
          const frame = new Frame(angle, x, y);
          this.fixedLeft = new Particle(x, y, true, "#f00");

          const rightpt = frame.toWorld(width, 0);
          this.fixedRight = new Particle(rightpt.x, rightpt.y, true, "#f00");
          particles.push(this.fixedLeft, this.fixedRight);

          const pos = frame.toWorld(0, hight);
          this.slider = new Ridged(
            [
              { x: 0, y: 0 },
              { x: width, y: 0 },
              { x: width / 2, y: -0.75 * hight },
            ],
            [
              [0, 1],
              [0, 2],
              [1, 2],
            ],
            { posX: pos.x, posY: pos.y, angle: angle, mass: 1 }
          );
          ridgedObjects.push(this.slider);

          const damp = 10;
          const spring = 500;
          this.leftSpring = new Spring(
            this.fixedLeft,
            this.slider,
            { x: 0, y: 0 },
            { x: 0, y: 0.0 },
            hight,
            spring,
            damp,
            { exp: 1 }
          );
          this.rightSpring = new Spring(
            this.fixedRight,
            this.slider,
            { x: 0, y: 0 },
            { x: width, y: 0.0 },
            hight,
            spring,
            damp,
            { exp: 1 }
          );
          springs.push(this.leftSpring, this.rightSpring);

          const resetPos = frame.toWorld(width / 2, hight + 1);
          const reset = new Particle(resetPos.x, resetPos.y, true, "#F4FAFC");
          this.resetSpring = new Spring(
            reset,
            this.slider,
            { x: 0, y: 0 },
            { x: width / 2, y: 0.0 },
            0.8,
            10,
            1,
            { color: "#FFC0CB", exp: 3 }
          );
          particles.push(reset);
          springs.push(this.resetSpring);

          this.thresh = this.slider.posX + 0.3;
        }

        isForward() {
          return this.slider.posX > this.thresh;
        }
      }

      const green = "#0fb619";
      const red = "#b60f0f";
      const purple = "#9a0fb6";

      class Lock {
        constructor(
          x,
          y,
          angle = 0,
          locked = 0,
          colors = [green, red, purple]
        ) {
          this.x = x;
          this.y = y;
          this.colors = colors;

          this.name = name;

          const frame = new Frame(angle, x, y);
          const width = 3;
          const hight = 1;
          const spread = 0.5;
          const lock_x_offset = 1;
          const lock_y_offset = 0.5;
          const extra = 0.0;

          const l1pos = frame.toWorld(width + lock_x_offset, hight);
          this.l1 = new DataLink(
            l1pos.x,
            l1pos.y,
            angle + Math.PI,
            width,
            hight
          );
          const l2pos = frame.toWorld(lock_x_offset, hight + spread);
          this.l2 = new DataLink(l2pos.x, l2pos.y, angle, width, hight);

          this.midSpring = new Spring(
            this.l1.slider,
            this.l2.slider,
            this.l1.slider.localPoints[2],
            this.l2.slider.localPoints[2],
            hight,
            100,
            20
          );
          springs.push(this.midSpring);

          // const lock1Pos = frame.toWorld(0, hight * 2 + extra - lock_y_offset);
          this.lock1PosOn = frame.toWorld(0, lock_y_offset);
          this.lock1PosOff = frame.toWorld(-1.5, lock_y_offset);
          this.lock1 = new Particle(this.lock1PosOn.x, this.lock1PosOn.y, true);
          this.lock1spring = new Spring(
            this.lock1,
            this.l1.slider,
            { x: 0, y: 0 },
            this.l1.slider.localPoints[1],
            1.9,
            20,
            20
          );
          this.lock2PosOn = frame.toWorld(
            0,
            hight * 2 + spread - lock_y_offset
          );
          this.lock2PosOff = frame.toWorld(
            -1.5,
            hight * 2 + spread - lock_y_offset
          );
          this.lock2 = new Particle(this.lock2PosOn.x, this.lock2PosOn.y, true);
          this.lock2spring = new Spring(
            this.lock2,
            this.l2.slider,
            { x: 0, y: 0 },
            this.l1.slider.localPoints[0],
            1.9,
            20,
            20
          );
          this.lock(locked);

          listeners.push(this);
        }

        update() {
          const topOn = this.l1.isForward();
          const botOn = this.l2.isForward();
          if (topOn && !botOn) {
            this.color(this.colors[0]);
          } else if (!topOn && botOn) {
            this.color(this.colors[1]);
          } else {
            this.color(this.colors[2]);
          }
        }

        color(color) {
          this.l1.slider.color = color;
          this.l2.slider.color = color;
        }

        lock(val) {
          function rm(arr, elm) {
            const index = arr.indexOf(elm);
            if (index > -1) {
              arr.splice(index, 1);
            }
          }

          rm(particles, this.lock1);
          rm(particles, this.lock2);
          rm(springs, this.lock1spring);
          rm(springs, this.lock2spring);

          this.lock1.target_speed = 0.01;
          this.lock2.target_speed = 0.01;
          if (val == 1) {
            this.lock1.target_x = this.lock1PosOn.x;
            this.lock1.target_y = this.lock1PosOn.y;
            particles.push(this.lock1);
            springs.push(this.lock1spring);
          } else if (val == -1) {
            this.lock1.target_x = this.lock1PosOff.x;
            this.lock1.target_y = this.lock1PosOff.y;
            particles.push(this.lock1);
            springs.push(this.lock1spring);
          } else if (val == 2) {
            this.lock2.target_x = this.lock2PosOn.x;
            this.lock2.target_y = this.lock2PosOn.y;
            particles.push(this.lock2);
            springs.push(this.lock2spring);
          } else if (val == -2) {
            this.lock2.target_x = this.lock2PosOff.x;
            this.lock2.target_y = this.lock2PosOff.y;
            particles.push(this.lock2);
            springs.push(this.lock2spring);
          }
        }
      }

      function connPt(pt, obj, objPt, springConst = 200, exp = 1) {
        const p = obj.localPoints[objPt];
        const g = obj.getWorldPoints()[objPt];
        const dist = Math.sqrt(
          Math.pow(g.x - pt.x, 2) + Math.pow(g.y - pt.y, 2)
        );
        const spring = new Spring(
          obj,
          pt,
          p,
          { x: 0, y: 0 },
          dist,
          springConst,
          2,
          { exp: exp }
        );
        springs.push(spring);
        return spring;
      }

      function conn(obj1, pt1, obj2, pt2, adjustLen = 0) {
        const p1 = obj1.localPoints[pt1];
        const p2 = obj2.localPoints[pt2];
        const g1 = obj1.getWorldPoints()[pt1];
        const g2 = obj2.getWorldPoints()[pt2];
        const dist = Math.sqrt(
          Math.pow(g1.x - g2.x, 2) + Math.pow(g1.y - g2.y, 2)
        );
        const spring = new Spring(
          obj1,
          obj2,
          p1,
          p2,
          dist + adjustLen,
          100,
          2,
          { exp: 1 }
        );
        springs.push(spring);
        return spring;
      }

      class OldBalance {
        constructor(x, y, angle) {
          this.frame = new Frame(angle, x, y);
          const frame = this.frame;

          function pt(x, y) {
            const pPos = frame.toWorld(x, y);
            const p = new Particle(pPos.x, pPos.y, true);
            particles.push(p);
            return p;
          }
          function line(x1, y1, x2, y2, opts = {}) {
            const p1 = frame.toWorld(x1, y1);
            const p2 = frame.toWorld(x2, y2);
            x1 = p1.x;
            x2 = p2.x;
            y1 = p1.y;
            y2 = p2.y;
            const r = new Ridged(
              [
                { x: 0, y: 0 },
                { x: x2 - x1, y: y2 - y1 },
              ],
              [[0, 1]],
              { posX: x1, posY: y1, ...opts }
            );
            ridgedObjects.push(r);
            return r;
          }

          function lock(x, y, angle, lock, colors) {
            const pos = frame.toWorld(x, y);
            return new Lock(pos.x, pos.y, angle, lock, colors);
          }

          this.top = lock(2, 0, 0.0, 0);
          this.holding = lock(9, 2.5, 0.0, 0, [red, green, purple]);
          this.bot = lock(2, 5, 0.0, 0);

          this.p = pt(0, (2.5 + 5) / 2);
          const clock = line(0, 2.5, 0, 5, { color: "#06bc17" });
          const clock_lock = new Spring(
            this.p,
            clock,
            { x: 0, y: 0 },
            { x: 0, y: (5 - 2.5) / 2 },
            0,
            300,
            20
          );
          springs.push(clock_lock);

          conn(this.top.l2.slider, 1, this.holding.l1.slider, 1);
          conn(this.bot.l1.slider, 0, this.holding.l2.slider, 0);
          this.clockTopSpring = conn(clock, 0, this.top.l2.slider, 0, -0.0);
          this.clockBotSpring = conn(clock, 1, this.bot.l1.slider, 1, -0.0);
          // line()
          // new T(5,5,4.5,4,1);
        }

        sendInput(input) {
          if (input == 0) {
            this.top.lock(0);
            this.bot.lock(0);
          } else if (input == 1) {
            this.top.lock(1);
            this.bot.lock(0);
          } else if (input == 2) {
            this.top.lock(0);
            this.bot.lock(2);
          }
        }
        tock() {
          const pPos = this.frame.toWorld(0, (2.5 + 5) / 2);
          this.p.target_speed = 0.02;
          this.p.target_x = pPos.x;
          this.p.target_y = pPos.y;
        }

        tick() {
          const pPos = this.frame.toWorld(0.7, (2.5 + 5) / 2);
          this.p.target_speed = 0.02;
          this.p.target_x = pPos.x;
          this.p.target_y = pPos.y;
        }
      }

      class Balance {
        constructor(x, y, hight) {
          this.x = x;
          this.y = y;
          this.hight = hight;

          // debugger;
          this.line = new Ridged(
            [
              { x: 0, y: hight / 2 },
              { x: 0, y: -hight / 2 },
              { x: 0, y: 0 },
            ],
            [[0, 1]],
            { posX: x, posY: y, angle: 0.0, mass: 5 }
          );

          // const resetPos = frame.toWorld(width / 2, hight + 1);
          // const reset = new Particle(resetPos.x, resetPos.y, true, "#F4FAFC");
          // this.resetSpring = new Spring(
          //   reset, this.slider, { x: 0, y: 0 }, { x: width / 2, y: 0.0 }, 0.8, 10, 1, { color: "#FFC0CB", exp: 3});
          // particles.push(reset);
          // springs.push(this.resetSpring);
          ridgedObjects.push(this.line);
          this.line.fixY = true;

          this.inputObj = this.line;
          this.inputIdx = 2;

          this.topObj = this.line;
          this.topIdx = 1;

          this.botObj = this.line;
          this.botIdx = 0;
        }
      }

      class BellCrank {
        constructor(x, y, ratio = 1) {
          this.inputIdx = 0;
          this.outputIdx = 2;
          this.obj = new Ridged(
            [
              { x: 0, y: 0 },
              { x: 0, y: 1.5 },
              { x: 1.5 * ratio, y: 1.5 },
            ],
            [
              [0, 1],
              [1, 2],
              [2, 0],
            ],
            { posX: x, posY: y, angle: 0 }
          );
          ridgedObjects.push(this.obj);
          const pivot = new Particle(x, y + 1.5, true);
          particles.push(pivot);
          connPt(pivot, this.obj, 1, 50000, 2);
        }
      }

      class Input {
        constructor(x, y, state, inputName = "", travel = 1, speed = 0.02) {
          this.x = x;
          this.y = y;
          this.p = new Particle(x, y, true);
          particles.push(this.p);
          this.travel = 1;
          this.state = 0;
          this.p.target_speed = speed;
          this.name = inputName;
          if (inputName) {
            this.trueBtn = document.getElementById(`${inputName}-button-true`);
            this.falseBtn = document.getElementById(
              `${inputName}-button-false`
            );
            this.set(state);
          }
        }

        set(state) {
          if (this.name === "clock") {
            console.log(`${this.name} button was triggered!`);
            if (state) {
              this.trueBtn.classList.add("green");
              this.falseBtn.classList.remove("red");
            } else {
              this.trueBtn.classList.remove("green");
              this.falseBtn.classList.add("red");
            }
          }
          if (state != this.state) {
            this.state = state;
            this.p.target_x = this.x + this.travel * state;
            this.p.target_y = this.y;
          }
        }
      }

      class Bool {
        constructor(x, y1, y0, inputName) {
          this.i1 = new Input(x, y1, 0);
          this.i0 = new Input(x, y0, 0);
          this.state = null;
          this.name = inputName; // 'A' or 'B'
          this.trueBtn = document.getElementById(`${inputName}-button-true`);
          this.falseBtn = document.getElementById(`${inputName}-button-false`);
          this.resetBtn = document.getElementById(`${inputName}-button-reset`);
          this.set(null);
        }

        set(state) {
          console.log(`${this.name} button pressed!`);
          this.state = state;
          if (state === null) {
            this.i0.set(0);
            this.i1.set(0);
            this.trueBtn.classList.remove("green");
            this.falseBtn.classList.remove("red");
            this.resetBtn.classList.add("grey");
          } else if (state) {
            // true
            this.i0.set(0);
            this.i1.set(1);
            this.trueBtn.classList.add("green");
            this.falseBtn.classList.remove("red");
            this.resetBtn.classList.remove("grey");
          } else {
            // false
            this.i0.set(1);
            this.i1.set(0);
            this.trueBtn.classList.remove("green");
            this.falseBtn.classList.add("red");
            this.resetBtn.classList.remove("grey");
          }
        }
      }

      const simulatedOutput = document.getElementById("simulated-result");
      function updateSimulatedOutputLabel(o0, o1) {
        // check the states of top row of both outputs
        const topTrue = o0.l1.isForward();
        const botTrue = o1.l1.isForward();

        if (topTrue && botTrue) {
          // error
          simulatedOutput.innerText = "ERROR";
          simulatedOutput.classList.add("black");
          simulatedOutput.classList.remove("green");
          simulatedOutput.classList.remove("grey");
          simulatedOutput.classList.remove("red");
        } else if (topTrue) {
          // true
          simulatedOutput.innerText = "true";
          simulatedOutput.classList.add("green");
          simulatedOutput.classList.remove("black");
          simulatedOutput.classList.remove("grey");
          simulatedOutput.classList.remove("red");
        } else if (botTrue) {
          // false
          simulatedOutput.innerText = "false";
          simulatedOutput.classList.add("red");
          simulatedOutput.classList.remove("green");
          simulatedOutput.classList.remove("grey");
          simulatedOutput.classList.remove("black");
        } else {
          // null
          simulatedOutput.innerText = "null";
          simulatedOutput.classList.add("grey");
          simulatedOutput.classList.remove("green");
          simulatedOutput.classList.remove("black");
          simulatedOutput.classList.remove("red");
        }
      }

      const equationI0 = document.getElementById("i0-result");
      const equationI1 = document.getElementById("i1-result");
      const expectedOutput = document.getElementById("expected-result");
      function updateTextLabels(i0, i1, o) {
        if (i0 === null) {
          equationI0.innerText = "null";
          equationI0.classList.add("grey");
          equationI0.classList.remove("green");
          equationI0.classList.remove("red");
        } else if (i0 === true) {
          equationI0.innerText = "true";
          equationI0.classList.add("green");
          equationI0.classList.remove("grey");
          equationI0.classList.remove("red");
        } else {
          equationI0.innerText = "false";
          equationI0.classList.add("red");
          equationI0.classList.remove("grey");
          equationI0.classList.remove("green");
        }

        if (i1 === null) {
          equationI1.innerText = "null";
          equationI1.classList.add("grey");
          equationI1.classList.remove("green");
          equationI1.classList.remove("red");
        } else if (i1 === true) {
          equationI1.innerText = "true";
          equationI1.classList.add("green");
          equationI1.classList.remove("grey");
          equationI1.classList.remove("red");
        } else {
          equationI1.innerText = "false";
          equationI1.classList.add("red");
          equationI1.classList.remove("grey");
          equationI1.classList.remove("green");
        }

        if (o === null) {
          expectedOutput.innerText = "null";
          expectedOutput.classList.add("grey");
          expectedOutput.classList.remove("green");
          expectedOutput.classList.remove("red");
        } else if (o === true) {
          expectedOutput.innerText = "true";
          expectedOutput.classList.add("green");
          expectedOutput.classList.remove("grey");
          expectedOutput.classList.remove("red");
        } else {
          expectedOutput.innerText = "false";
          expectedOutput.classList.add("red");
          expectedOutput.classList.remove("grey");
          expectedOutput.classList.remove("green");
        }
      }

      function calculateExpectedOutput(i0, i1) {
        let inputA = i0.state;
        let inputB = i1.state;
        let outputExpected = null;
        if (!(inputA === null) && !(inputB === null))
          outputExpected = !(inputA && inputB);
        console.log(`${inputA} NAND ${inputB} = ${outputExpected}`);
        updateTextLabels(inputA, inputB, outputExpected);
      }

      // function conMulti(conns) {
      //   gpts = conns.map( elm => {
      //     if (elm instanceof Particle) {
      //       return { x: elm.x, y: elm.y };
      //     } else {
      //       return elm[0].getWorldPoints()[elm[1]];
      //     }
      //   });

      //   let r = new Ridged(
      //     gpts,
      //     Array(gpts.length - 1).keys().map(i => [i, i + 1]),
      //     { posX: 0, posY: 0, angle: 0, color: "#55555" },
      //   );
      //   ridgedObjects.push(r);

      //   for (let [index, value] of conns.entries()) {
      //     if (value instanceof Particle) {
      //       connPt(value, r, index);
      //     } else {
      //       conn(r, index, value[0], value[1]);
      //     }
      //   }
      //   window.asdf = r;
      // }

      class Route {
        constructor(yIn, yOuts, x) {
          this.bellIn = new BellCrank(x, yIn);
          this.bellsOut = yOuts.map((y) => {
            return new BellCrank(x, y);
          });
          for (let i = 0; i < yOuts.length; i++) {
            if (i == 0) {
              conn(
                this.bellIn.obj,
                this.bellIn.outputIdx,
                this.bellsOut[i].obj,
                this.bellsOut[i].outputIdx
              );
            } else {
              conn(
                this.bellsOut[i - 1].obj,
                this.bellsOut[i - 1].outputIdx,
                this.bellsOut[i].obj,
                this.bellsOut[i].outputIdx
              );
            }
          }

          this.inputObj = this.bellIn.obj;
          this.inputIdx = this.bellIn.inputIdx;
          this.outputObj = this.bellsOut.map((bell) => {
            return bell.obj;
          });
          this.outputIdx = this.bellsOut[0].inputIdx;
        }
      }

      function range(n) {
        return [...Array(n).keys()];
      }

      var out1, out2;
      function mine() {
        // const bal = new Balance(1, 1, 0);
        // window.bal = bal;
        // window.tick = bal.tick.bind(bal);
        // window.tock = bal.tock.bind(bal);
        // bal.sendInput(1);

        let b = new Bool(2, 8, 10, "B");
        let a = new Bool(2, 2, 4, "A");
        window.a = a;
        window.b = b;

        let locks = [27, 40].map((x) =>
          [14, 19, 24, 29].map((y) => {
            return new Lock(x, y, 0, 0, [red, green, purple]);
          })
        );

        function rr(input, locks, x) {
          let route = new Route(
            input.y,
            locks.map((l) => l.y),
            x
          );
          connPt(input.p, route.inputObj, route.inputIdx);
          for (let i = 0; i < locks.length; i++) {
            conn(route.outputObj[i], route.outputIdx, locks[i].l1.slider, 1);
          }
        }

        rr(b.i1, [locks[0][0], locks[0][1]], 20);
        rr(b.i0, [locks[0][2], locks[0][3]], 22);
        rr(a.i1, [locks[1][0], locks[1][2]], 33);
        rr(a.i0, [locks[1][1], locks[1][3]], 36);

        let b2 = new Balance(10, locks[0][0].y + 2.5 + 2.5, 5);
        let b3 = new Balance(10, locks[0][2].y + 2.5 + 2.5, 5);
        let b1 = new Balance(4, (b2.y + b3.y) / 2, b3.y - b2.y);
        window.bs = [b1, b2, b3];
        conn(b1.line, b1.topIdx, b2.line, b2.inputIdx).fixY = true;
        conn(b1.line, b1.botIdx, b3.line, b3.inputIdx).fixY = true;

        let c = new Input(2, b1.y, 0, "clock");
        let t = (connPt(c.p, b1.line, b1.inputIdx).fixY = true);
        t.fixY = true;
        window.c = c;

        let b4 = new Balance(50, locks[0][0].y + 2.5 + 2.5, 5);
        // let b5 = new Balance(50, locks[0][2].y + 2.5 + 2.5, 5);
        let b5 = new Balance(55, locks[0][0].y + 8.75, 7.5);

        let gear = new BellCrank(60, b5.y, 3);
        let gearRedirect = new BellCrank(62, b5.y + 5);
        out1 = new Lock(68, b5.y + 5, 0, 0, [green, red, purple]);
        out2 = new Lock(68, locks[1][3].y + 2.5, 0, 0, [green, red, purple]);

        let ss = [
          conn(b2.line, b2.topIdx, locks[0][0].l2.slider, 0),
          conn(b2.line, b2.botIdx, locks[0][1].l2.slider, 0),
          conn(b3.line, b3.topIdx, locks[0][2].l2.slider, 0),
          conn(b3.line, b3.botIdx, locks[0][3].l2.slider, 0),

          conn(locks[0][0].l2.slider, 1, locks[1][0].l2.slider, 0),
          conn(locks[0][1].l2.slider, 1, locks[1][1].l2.slider, 0),
          conn(locks[0][2].l2.slider, 1, locks[1][2].l2.slider, 0),
          conn(locks[0][3].l2.slider, 1, locks[1][3].l2.slider, 0),

          conn(locks[1][0].l2.slider, 1, b4.line, b4.topIdx),
          conn(locks[1][1].l2.slider, 1, b4.line, b4.botIdx),
          conn(locks[1][2].l2.slider, 1, b5.line, b5.botIdx),

          conn(b4.line, b4.inputIdx, b5.line, b5.topIdx),

          conn(b5.line, b5.inputIdx, gear.obj, gear.inputIdx),
          conn(locks[1][3].l2.slider, 1, out2.l1.slider, 0),

          conn(
            gear.obj,
            gear.outputIdx,
            gearRedirect.obj,
            gearRedirect.outputIdx
          ),
          conn(gearRedirect.obj, gearRedirect.inputIdx, out1.l1.slider, 0),
        ];
        ss.map((s) => (s.stiffness = 20));

        // conn(b3.line, b1.topIdx, b2.line, b2.inputIdx).fixY = true;
        // conn(b1.line, b1.botIdx, b3.line, b3.inputIdx).fixY = true;
      }

      mine();
      // --- Main Simulation Loop ---
      function update() {
        // Gravity for particles
        particles.forEach((p) => {
          if (!p.fixed) p.applyForce(0, gravity);
        });
        particles.forEach((p) => p.update());
        ridgedObjects.forEach((r) => r.update());
        springs.forEach((s) => s.update());
        listeners.forEach((l) => l.update());
        updateSimulatedOutputLabel(out1, out2);
      }
      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        particles.forEach((p) => p.draw(ctx));
        ridgedObjects.forEach((r) => r.draw(ctx));
        springs.forEach((s) => s.draw(ctx));
      }
      function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
      }
      loop();

      // console.log(asdf.angle);
      // console.log(asdf);
      // draw();
      // update();
    </script>
  </body>
</html>
